# 2-let和const命令

学习时间:  120min

## 知识点汇总

1. `let`用于声明变量，所声明的变量只在`let`所在的代码块内有效。

2. `let` 不存在变量提升的现象。变量使用前必须先声明。

3. **暂时性死区(temporal dead zone)**：只要块级作用域内存在`let` ，它所声明的变量就绑定（binding）了这个区域，不受外部影响。如果代码块中存在`let`或者`const` ，则这个区块对这些命令声明的变量从一开始就形成封闭作用域。只要在申明之前使用这些变量就会报错。在代码块里，变量声明之前都是不可用的。

   ```
   var tmp = 123;

   if(true){
     tmp = 'abc';//ReferenceError
     let tmp;
   }
   ```

4. **不允许重复声明**:`let`不允许在相同作用域内重复声明同一个变量。

   ```
   function func(arg) {
     let arg; // 报错
   }
   ```

5. ES5没有**块级作用域** 的缺点：（1）内层变量可能会覆盖外层变量（2）用来计数的循环变量泄露为全局变量

6. ES6允许块级作用域任意嵌套，因此内层作用域可以定义与外层作用域同名的变量。

7. 块级作用域外部无法调用块级作用域内定义的函数。

8. **块级作用域与函数声明** ES6允许在块级作用域之中声明函数，块级作用域之中，函数声明语句的行为类似于`let`，在块级作用域之外不可引用。（注意：在ES6 浏览器中，这些有特殊情况

9. `const` 用来声明常量，一旦声明就不能改变。一旦声明变量，就要进行初始化，只声明不赋值就会报错。`const` 只在声明所在的块级作用域内有效、声明的常量也是不提升、同样存在暂时性死区、只能在声明的位置后面使用、不可重复声明。

10. `const`实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。简单类型和复合类型，`const`只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构如果是复合类型就可能是可变的。

11. ES6声明变量的方法:`var`命令和`function`命令,`let`和`const`命令，` import`和`class`

12. **顶层对象**，在浏览器环境指的是`window`对象，在 Node 指的是`global`对象。

13. ES6 为了保持兼容性，`var`命令和`function`命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，`let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性。

14. 注意严格模式和普通模式的不同。




## 疑惑

1. ```
   var a = [];
   for(let i = 0; i < 10; i++){
     a[i] = function(){
       console.log(i);
     };
   }
   a[6]();//6
   ```

   问题：为什么`a[6]()`可以执行，是因为调用了全局作用域的a函数吗？

   理解：

   - 此处的`let` 变量只在循环内有效，退出循环后没有`i` 这个变量
   - `a` 是全局变量，是一个数组
   - 在循环里，数组a的每一项被赋值为一个函数，即`a[i] = function(){}`是一个函数表达式，因此，`a[0] = function(){ console.log(0);}` 以此类推到`a[9]`
   - `a[6]()` 是调用函数的一种方式，对应它的函数表达式，因此调用了`a[6] = function(){ console.log(6);}`  因此输出6
   - 要注意的是：变量`i`是`let`声明的，当前的`i`只在本轮循环有效，所以每一次循环的`i`其实都是一个新的变量， JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量`i`时，就在上一轮循环的基础上进行计算。就类似C++的`for`循环。

2. ES6规定的暂时性死区和不存在变量提升是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。

   问题：这种意料之外的行为有哪些？

   有待发现

3. ```
   function func(arg) {
     let arg; // 报错
   }
   ```

   问题：这里第一个`arg` 的作用域是哪里？

4. 问题：块级作用域的出现可以完全取代立即执行函数（IIFE）吗？

5. 问题：什么情况下需要引入顶层对象？

6. 问题：什么时候会用到严格模式？

