# 3-变量的解构赋值

学习时间:  120min

## 知识点汇总

1. ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）

   ```javascript
   let [a, b, c] = [1, 2, 3];//数组
   let { foo, bar } = { foo: "aaa", bar: "bbb" };//对象
   const [a, b, c, d, e] = 'hello';//字符串
   ```

2. 本质上，这种写法属于“**模式匹配**”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。

3. 对于 Set 结构，也可以使用数组的解构赋值。

   ```
   let [x, y, z] = new Set(['a', 'b', 'c']);
   x // "a"
   ```

4. ES6 内部使用严格相等运算符（`===`），判断一个位置是否有值。

5. 解构赋值允许指定默认值，**默认值**生效的条件是，数组成员或对象的属性值严格等于`undefined`，（如果一个数组成员是`null`，默认值就不会生效，因为`null`不严格等于`undefined`）。`undefined`就会触发函数参数的默认值。

6. 如果默认值是一个**表达式** ，表达式是惰性求值的，只有在用到时候才会求值。

7. 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。

   ```javascript
   let [x = 1, y = x] = [];     // x=1; y=1
   ```

8. 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。

9. 对象的解构赋值是下面形式的简写：

   ```javascript
   let { foo: foo, bar: bar } = { foo: "aaa", bar: "bbb" };
   let { foo: baz } = { foo: "aaa", bar: "bbb" };
   baz // "aaa"
   foo // error: foo is not defined
   ```

   也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。`foo`是匹配的模式，`baz`才是变量。真正被赋值的是变量`baz`，而不是模式`foo`。

   ```
   const node = {
     loc: {
       start: {
         line: 1,
         column: 5
       }
     }
   };

   let { loc, loc: { start }, loc: { start: { line }} } = node;
   line // 1
   loc  // Object {start: Object}
   start // Object {line: 1, column: 5}
   ```

   这段代码中，每一个解构赋值中被赋值的变量分别为：`loc`、`start`、`line`。

10. 类似数组的对象都有一个`length`属性，因此还可以对这个属性解构赋值。

  ```
  let {length : len} = 'hello';
  len // 5
  ```

11. 将一个已经声明的变量用于解构赋值必须小心， JavaScript 引擎可能将其理解成一个代码块。

12. 解构赋值允许等号左边的模式之中，不放置任何变量名。

13. 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。

    ```javascript
    let arr = [1, 2, 3];
    let {0 : first, [arr.length - 1] : last} = arr;
    first // 1
    last // 3
    ```

    上面代码对数组进行对象解构。数组`arr`的`0`键对应的值是`1`，`[arr.length - 1]`就是`2`键，对应的值是`3`。方括号这种写法，属于“属性名表达式”（参见《对象的扩展》一章）

14. 数值和布尔值的解构赋值：解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。数值和布尔值的包装对象都有`toString`属性。由于`undefined`和`null`无法转为对象，所以对它们进行解构赋值，都会报错。

    ```javascript
    let {toString: s} = 123;
    s === Number.prototype.toString // true

    let {toString: s} = true;
    s === Boolean.prototype.toString // true
    ```

15. 函数参数的解构赋值：

    ```javascript
    function add([x, y]){
      return x + y;
    }

    add([1, 2]); // 3
    ```

    ```javascript
    function move({x = 0, y = 0} = {}) {
      return [x, y];
    }

    move({x: 3, y: 8}); // [3, 8]
    move({x: 3}); // [3, 0]
    move({}); // [0, 0]
    move(); // [0, 0]
    ```

    与这段代码比较，下面代码的写法会得到不一样的结果

    ```js
    function move({x, y} = { x: 0, y: 0 }) {
      return [x, y];
    }

    move({x: 3, y: 8}); // [3, 8]
    move({x: 3}); // [3, undefined]
    move({}); // [undefined, undefined]
    move(); // [0, 0]
    ```

    第二段代码是为函数`move`的参数指定默认值，而不是为变量`x`和`y`指定默认值，所以会得到与前一种写法不同的结果。

    

## 总结

1. **结构不成功时候，变量的值会被赋为`undefined` **。**不完全结构** 时候，左边只匹配一部分等号右边的数组。左边的数组长度<=右边的数组长度才可以结构成功，如果等号右边不是数组（严格上，不是可以遍历的结构）就会报错。（本质原因是，等号右边的值要么转为对象以后不具备 Iterator 接口，要么本身就不具备 Iterator 接口，只要某种数据结构**具有 Iterator 接口** ，都可以采用数组形式的解构赋值。）

2. 变量的解构赋值分为：数组的解构赋值、对象的解构赋值、字符串的解构赋值、数值和布尔值的解构赋值、函数参数的解构赋值。数组和对象的结构赋值均可以用于嵌套的结构、均可以指定默认值。

3. 解构赋值的用途：

   - **交换变量的值**
   - **从函数返回多个值**
   - **函数参数的定义**
   - **提取 JSON 数据**
   - **函数参数的默认值**
   - **遍历 Map 结构**
   - **输入模块的指定方法**

4. 对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。如果模式中出现圆括号怎么处理：

   可以使用**圆括号** 的情况：赋值语句的非模式部分

   ```
   [(b)] = [3]; // 正确
   ({ p: (d) } = {}); // 正确
   [(parseInt.prop)] = [3]; // 正确
   ```

   不可以使用圆括号的情况：

   - 变量声明语句

   - 函数参数（**函数参数也属于变量声明**）

   - 赋值语句的模式

     

## 疑惑

Q:

```javascript
let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = ['a'];
x // "a"
y // undefined
z // []
```

这里那三个点是什么意？



Q: 什么是Set结构？



Q:

```js
var {x = 3} = {};
x // 3

var {x, y = 5} = {x: 1};
x // 1
y // 5

var {x: y = 3} = {};
y // 3

var {x: y = 3} = {x: 5};
y // 5
```

为什么默认值可以是一个没有声明过的`y` 



Q:如果默认值是一个**表达式** ，表达式是惰性求值的，只有在用到时候才会求值。那么什么时候才是“用到的时候”呢？



Q: 如果已经指定了默认值，那么进行解构赋值还有没有意义呢？这之中引擎会做些什么？



Q: 

```javascript
let arr = [1, 2, 3];
let {0 : first, [arr.length - 1] : last} = arr;
first // 1
last // 3
```

看起来，这里的`0` , `[2]`可以直接作为模式?



Q:

Iterator 接口？（貌似要参考后面要学习的章节）



Q:如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。

```js
// 报错
let {foo: {bar}} = {baz: 'baz'};

```

上面代码中，等号左边对象的`foo`属性，对应一个子对象。该子对象的`bar`属性，解构时会报错。原因很简单，因为`foo`这时等于`undefined`，再取子属性就会报错，请看下面的代码。

(这段教程不太懂)



Q:

函数参数的解构也可以使用默认值。

```js
function move({x = 0, y = 0} = {}) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]

```

上面代码中，函数`move`的参数是一个对象，通过对这个对象进行解构，得到变量`x`和`y`的值。如果解构失败，`x`和`y`等于默认值。

注意，下面的写法会得到不一样的结果。

```js
function move({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, undefined]
move({}); // [undefined, undefined]
move(); // [0, 0]

```

上面代码是为函数`move`的参数指定默认值，而不是为变量`x`和`y`指定默认值，所以会得到与前一种写法不同的结果。

(这段教程不太懂)  为参数指定默认值和为变量指定默认值的不同

 

## 感想

这一章，我看了两次，个人认为这一章应该先从结尾开始看。因为第一次看时候看得很迷茫，不知道它这种语法是干嘛用的，虽然知道可以这么做，但完全不知道这样做的意义，可能是自己缺乏深入的思考所以不知道它的用途。第二次看的时候，因为知道这种语法的用途之后，更能理解这个语法。

